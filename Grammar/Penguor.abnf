;
; Penguor Language
; ----------------
;
; (c) Carl Schierig 2019-2020
;
; abnf grammar according to https://tools.ietf.org/html/rfc5234
; and https://tools.ietf.org/html/rfc7405

program = *declaration EOF

declaration  = ( [ accessMod ] *nonAccessMod ( sysDecl / dataDecl / typeDecl / functionDecl / varDecl / libDecl ) )
declaration /= usingDecl / compilerStmt

usingDecl    = %s"using" call ENDING
sysDecl      = %s"system" IDENTIFIER [ "<" call ] blockDecl
dataDecl     = %s"data" IDENTIFIER [ "<" call ] blockDecl
typeDecl     = %s"type" IDENTIFIER [ "<" call ] blockDecl
functionDecl = varExpr "(" [ parameters ] ")" declContent
varDecl      = varExpr [ "=" conditionalOrExpr ] ENDING
libDecl      = %s"library" IDENTIFIER *( "." IDENTIFIER ) blockDecl

; stmtblockDecl and blockDecl are both represented by a BlockDecl in PenguorCS, 
; with the difference that one allows DeclStmts
stmtblockDecl = "{" *( declaration / statement ) "}"
blockDecl     = "{" *declaration "}"
declContent   = stmtblockDecl
              / ":" statement

statement = compilerStmt
          / blockStmt
          / varStmt
          / ifStmt
          / whileStmt
          / forStmt
          / doStmt
          / switchStmt
          / expressionStmt

compilerStmt = "#" compilerDirective ENDING
compilerDirective = %s"safety" ( 0 / 1 / 2 )

blockStmt      = "{" *statement "}"

; the difference between a varStmt and a varDecl
; is that the varDecl is only called from declaration otherwise
; the varStmt may not have any access modifiers
varStmt        = varDecl

ifStmt         = %s"if" "(" expression ")" statement *elif [ %s"else" statement ]
elif           = %s"elif" "(" expression ")" statement

whileStmt      = %s"while" "(" expression ")" statement 
forStmt        = %s"for" "(" varExpr ":" call ")" statement
doStmt         = %s"do" statement %s"while" "(" expression ")" ";"
switchStmt     = %s"switch" "(" call ")" "{" 1*( caseStmt ) [ %s"default" ":" statement ] "}"
caseStmt       = %s"case" expression ":" statement

returnStmt     = %s"return" [ expression ] ENDING

expressionStmt = expression ENDING


expression     = assignmentExpr

assignmentExpr     = conditionalOrExpr [ ( "=" / "+=" / "-=" / "*=" / "/=" / "%=" / "<<=" / ">>=" / "&=" / "|=" / "^=" ) conditionalOrExpr ]
conditionalOrExpr  = conditionalXorExpr [ "||" conditionalOrExpr ]
conditionalXorExpr = conditionalAndExpr [ "^^" conditionalXorExpr ]
conditionalAndExpr = bitwiseOrExpr [ "&&" conditionalAndExpr ]
bitwiseOrExpr      = bitwiseXorExpr [ "|" bitwiseOrExpr ]
bitwiseXorExpr     = bitwiseAndExpr [ "^" bitwiseXorExpr ]
bitwiseAndExpr     = equalityExpr [ "&" bitwiseAndExpr ]
equalityExpr       = relationExpr [ ( "==" / "!=" ) equalityExpr ]
relationExpr       = bitshiftExpr [ ( "<" /  ">" / "<=" / ">=" ) relationExpr ]
bitshiftExpr       = additionExpr [ ( "<<" / ">>" ) bitshiftExpr ]
additionExpr       = multiplicationExpr [ ( "+" / "-" ) additionExpr ]
multiplicationExpr = unaryExpr [ ( "*" / "/" / "%" ) multiplicationExpr ]
unaryExpr          = [ "!" / "+" / "-" / "~" / "++" / "--" ] base / groupingExpr
base           = keyword / NUM / STRING / call

call           = IDENTIFIER [ ( "." call ) / ( "++" / "--" ) / ( "[" "]" ) ]
               / callFunction [ "." call ]
callFunction = IDENTIFIER "(" [ arguments ] ")"

keyword = %s"true" / %s"false" / %s"null"
varExpr = call IDENTIFIER

groupingExpr       = "(" expression ")"

parameters = varExpr *( "," varExpr )
arguments  = expression *( "," expression )

accessMod = %s"public" / %s"private" / %s"protected" / %s"restricted"
nonAccessMod = [ %s"static" / %s"dynamic" ] [ %s"abstract" ] [ %s"const" ]

; Regular grammar

IDENTIFIER = ( ALPHA / %x95 ) *( ALPHA / DIGIT / %x95 ) ; %x95 = '_'

NUM = 1*DIGIT [ "." DIGIT+ ]
    / *DIGIT "." 1*DIGIT

STRING = DQUOTE *(CHAR) DQUOTE

ENDING = ";" / NEWLINE
NEWLINE = LF / CRLF