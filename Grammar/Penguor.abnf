; 
; Penguor Language
; ----------------
;
; (c) Carl Schierig 2020

; abnf grammar according to https://tools.ietf.org/html/rfc2234

program = declaration* EOF


declaration = sysDec
            / contDec
            / dtypeDec
            / varDec
            / functionDec
            / libDec
            / statement

sysDec   = "system" IDENTIFIER [ "<" IDENTIFIER ] blockStmt

contDec  = "container" IDENTIFIER [ "<" IDENTIFIER ] blockStmt

dtypeDec = "datatype" IDENTIFIER [ "<" IDENTIFIER ] blockStmt


varDec      = "var" IDENTIFIER IDENTIFIER [ "=" expression ] [";"] ; TODO: semicolon sometimes optional, e.g. params

functionDec = "fn" IDENTIFIER IDENTIFIER "(" [ parameters ] ")" blockStmt

libDec      = "library" IDENTIFIER blockStmt


statement = preProcessorStmt
          / blockStmt
          / ifStmt
          / whileStmt
          / forStmt
          / doStmt
          / switchStmt
          / expressionStmt


preProcessorStmt = "#" ppDirective CRLF

ppDirective = "include" IDENTIFIER
             / "from" IDENTIFIER "include" IDENTIFIER
             / "safety" ( 0 / 1 / 2 )


blockStmt      = "{" *declaration "}"

ifStmt         = "if" "(" expression ")" "{" 1*statement "}" *elif [ else "{" 1*statement "}" ]

elif           = "elif" "(" expression ")" "{" 1*statement "}"


whileStmt      = "while" "(" expression ")" "{" 1*statement "}"

forStmt        = "for" "(" varDec ":" IDENTIFIER ")" "{" 1*statement "}"

doStmt         = "do" "{" 1*statement "}" "while" "(" expression ")"

switchStmt     = "switch" "(" IDENTIFIER ")" "{" 1*( caseStmt ) [ "default" ":" 1*statement ] "}"

caseStmt       = "case" "(" expression ")" ":" *statement

expressionStmt = expression ";"



expression     = assignment

assignment     = call "=" assignment
                /  logicOr 

logicOr        = logicAnd *( "||" logicAnd )

logicAnd       = equality *( "&&" equality )

equality       = relation *( ( "==" / "!=" ) relation )

relation       = addition *( ( "<" /  ">" / "<=" / ">=" ) addition )

addition       = multiplication *( ( "+" / "-" ) multiplication )

multiplication = unary *( ( "*" / "/" ) unary )

unary          = [ "!" / "-" ] unary / call / grouping

call           = IDENTIFIER *( "." IDENTIFIER ) [ "(" [ arguments ] ")" ] [ base ]

base           = IDENTIFIER / NUM / STRING / "true" / "false" / "null"

grouping       = "(" expression ")"


parameters = varDec *( "," varDec )

arguments  = expression *( "," expression )



; Regular grammar

IDENTIFIER = ALPHA *( ALPHA / DIGIT ) 

NUM = 1*DIGIT [ "." DIGIT+ ]
    / *DIGIT "." 1*DIGIT

STRING = DQUOTE *(CHAR) DQUOTE
