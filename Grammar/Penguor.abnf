; 
; Penguor Language
; ----------------
;
; (c) Carl Schierig 2020
;
; abnf grammar according to https://tools.ietf.org/html/rfc2234

program = *declaration EOF

declaration = usingDec
            / sysDec
            / contDec
            / dtypeDec
            / functionDec
            / libDec
            / statement

usingDec    = "using" call ";" 
sysDec      = [ accessMod ] *nonAccessMod "system" IDENTIFIER [ "<" IDENTIFIER ] blockStmt
contDec     = [ accessMod ] *nonAccessMod "container" IDENTIFIER [ "<" IDENTIFIER ] blockStmt
dtypeDec    = [ accessMod ] *nonAccessMod "datatype" IDENTIFIER [ "<" IDENTIFIER ] blockStmt
functionDec = [ accessMod ] *nonAccessMod IDENTIFIER IDENTIFIER "(" [ parameters ] ")" blockStmt
libDec      = "library" IDENTIFIER blockStmt


statement = preProcessorStmt
          / blockStmt
          / ifStmt
          / whileStmt
          / forStmt
          / doStmt
          / switchStmt
          / expressionStmt

preProcessorStmt = "#" ppDirective NEWLINE
ppDirective = "safety" ( 0 / 1 / 2 )

blockStmt      = "{" *declaration "}"

ifStmt         = "if" "(" expression ")" "{" 1*statement "}" *elif [ "else" "{" 1*statement "}" ]
elif           = "elif" "(" expression ")" "{" 1*statement "}"

whileStmt      = "while" "(" expression ")" "{" 1*statement "}"
forStmt        = "for" "(" statement ":" expression ")" "{" 1*statement "}"
doStmt         = "do" "{" 1*statement "}" "while" "(" expression ")" ";"
switchStmt     = "switch" "(" expression ")" "{" 1*( caseStmt ) [ "default" ":" "{" 1*statement "}" ] "}" ; improve grammar & parser to allow for
caseStmt       = "case" expression ":" "{" *statement "}"

expressionStmt = expression ";"


expression     = assignmentExpr

assignmentExpr     = logicOrExpr [ ( "=" / "+=" / "-=" / "*=" / "/=" / "%=" / "<<=" / ">>=" / "&=" / "|=" / "^=" ) logicOrExpr ]
logicOrExpr        = logicXorExpr [ "||" logicOrExpr ]
logicXorExpr       = logicAndExpr [ "^^" logicXorExpr ]
logicAndExpr       = bitwiseOrExpr [ "&&" logicAndExpr ]
bitwiseOrExpr      = bitwiseXorExpr [ "|" bitwiseOrExpr ]
bitwiseXorExpr     = bitwiseAndExpr [ "^" bitwiseXorExpr ]
bitwiseAndExpr     = equalityExpr [ "&" bitwiseAndExpr ]
equalityExpr       = relationExpr [ ( "==" / "!=" ) equalityExpr ]
relationExpr       = bitshiftExpr [ ( "<" /  ">" / "<=" / ">=" ) relationExpr ]
bitshiftExpr       = additionExpr [ ( "<<" / ">>" ) bitshiftExpr ]
additionExpr       = multiplicationExpr [ ( "+" / "-" ) additionExpr ]
multiplicationExpr = unaryExpr [ ( "*" / "/" / "%" ) multiplicationExpr ]
unaryExpr          = [ "!" / "-" / "~" / "++" / "--" ] unaryExpr / base / groupingExpr
base           = keyword / varExpr / call / IDENTIFIER / NUM / STRING

call           = IDENTIFIER [ ( "." call ) / ( "++" / "--" ) ]
               / callFunction [ "." call ]
callFunction = IDENTIFIER "(" [ arguments ] ")"

keyword = "true" / "false" / "null"
varExpr = [ accessMod ] *nonAccessMod call IDENTIFIER [ "=" logicOrExpr ]

groupingExpr       = "(" expression ")"

parameters = varDec *( "," varDec )
arguments  = expression *( "," expression )

accessMod = "public" / "private" / "protected" / "restricted"
nonAccessMod = [ "static" / "dynamic" ] [ "abstract" / "const" ]

; Regular grammar

IDENTIFIER = ( ALPHA / %x95 ) *( ALPHA / DIGIT / %x95 )

NUM = 1*DIGIT [ "." DIGIT+ ]
    / *DIGIT "." 1*DIGIT

STRING = DQUOTE *(CHAR) DQUOTE

NEWLINE = LF / CRLF