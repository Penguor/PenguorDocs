;
; Penguor Language
; ----------------
;
; (c) Carl Schierig 2019-2021
;
; abnf grammar according to https://tools.ietf.org/html/rfc5234
; and https://tools.ietf.org/html/rfc7405

program = *declaration EOF


declaration           = modifiedDecl / embeddedDeclaration

modifiableDeclaration = sysDecl / dataDecl / typeDecl / functionDecl / varDecl / libraryDecl
embeddedDeclaration   = usingDecl / functionDecl / stmtDecl

modifiedDecl = [ accessMod ] [ nonAccessMod ] modifiableDeclaration

usingDecl    = %s"using" typeCall ENDING
sysDecl      = %s"system" IDENTIFIER [ "<" call ] blockDecl
dataDecl     = %s"data" IDENTIFIER [ "<" call ] blockDecl
typeDecl     = %s"type" IDENTIFIER [ "<" call ] blockDecl
functionDecl = varExpr "(" [ parameters ] ")" declContent
varDecl      = varExpr [ "=" conditionalOrExpr ] ENDING
libraryDecl  = %s"library" IDENTIFIER *( "." IDENTIFIER ) blockDecl

stmtBlockDecl = "{" *embeddedDeclaration "}"
blockDecl     = "{" *declaration "}"
declContent   = stmtblockDecl
              / ":" statement

stmtDecl = statement

statement = compilerStmt
          / blockStmt
          / varStmt
          / ifStmt
          / whileStmt
          / forStmt
          / doStmt
          / switchStmt
          / expressionStmt

compilerStmt = "#" compilerDirective ENDING
compilerDirective = %s"safety" ( "0" / "1" / "2" )

blockStmt      = "{" *statement "}"

; the difference between a varStmt and a varDecl
; is that the varDecl is only called from declaration otherwise
; the varStmt may not have any access modifiers
varStmt        = varDecl

ifStmt         = %s"if" "(" expression ")" statement [ %s"else" statement ]

whileStmt      = %s"while" "(" expression ")" statement
forStmt        = %s"for" "(" varExpr ":" callExpr ")" statement
doStmt         = %s"do" statement %s"while" "(" expression ")" ";"
switchStmt     = %s"switch" "(" call ")" "{" 1*( caseStmt ) [ %s"default" ":" statement ] "}"
caseStmt       = %s"case" expression ":" statement

assemblyStmt   = %s"asm" "(" arguments ")" DQUOTE 'assembly code' DQUOTE ; contains (NASM) assembly, platform specific and intended for standard library, assembly code is a string

returnStmt     = %s"return" [ expression ] ENDING

expressionStmt = expression ENDING


expression     = assignmentExpr

assignmentExpr     = conditionalOrExpr / call assignmentRight
assignmentRight    = ( "=" / "+=" / "-=" / "*=" / "/=" / "%=" / "<<=" / ">>=" / "&=" / "|=" / "^=" ) conditionalOrExpr
conditionalOrExpr  = conditionalAndExpr [ "||" conditionalOrExpr ]
conditionalAndExpr = bitwiseOrExpr [ "&&" conditionalAndExpr ]
bitwiseOrExpr      = bitwiseXorExpr [ "|" bitwiseOrExpr ]
bitwiseXorExpr     = bitwiseAndExpr [ "^" bitwiseXorExpr ]
bitwiseAndExpr     = equalityExpr [ "&" bitwiseAndExpr ]
equalityExpr       = relationExpr [ ( "==" / "!=" ) equalityExpr ]
relationExpr       = bitshiftExpr [ ( "<" /  ">" / "<=" / ">=" ) relationExpr ]
bitshiftExpr       = additionExpr [ ( "<<" / ">>" ) bitshiftExpr ]
additionExpr       = multiplicationExpr [ ( "+" / "-" ) additionExpr ]
multiplicationExpr = unaryExpr [ ( "*" / "/" / "%" ) multiplicationExpr ]
unaryExpr          = [ "!" / "+" / "-" / "~" / "++" / "--" ] base / groupingExpr
base               = keyword / NUM / STRING / char / callExpr

callExpr     = chainableCall ( "." chainableCall ) ( "++" / "--" )
typeCallExpr = typeCall / arrayTypeCall

typeCall = IDENTIFIER *( "." IDENTIFIER )
arrayTypeCall = IDENTIFIER *( "." IDENTIFIER ) 1*( "[" *( "," ) "]" )

chainableCall = idfCall
              / functionCall
              / arrayCall

idfCall      = IDENTIFIER
functionCall = IDENTIFIER "(" [ arguments ] ")"
arrayCall    = IDENTIFIER *( "[" expression *( "," expression ) "]" )


keyword = %s"true" / %s"false" / %s"null"
varExpr = typeCallExpr IDENTIFIER

groupingExpr = "(" expression ")"

parameters = varExpr *( "," varExpr )
arguments  = expression *( "," expression )

accessMod = %s"public" / %s"private" / %s"protected" / %s"restricted"
nonAccessMod =  %s"static" / %s"dynamic" / %s"abstract" / %s"const"

; Regular grammar

IDENTIFIER = ( ALPHA / %x95 ) *( ALPHA / DIGIT / %x95 ) ; %x95 = '_'

;       any base      or  base    2  ,  8  ,  16 or 10      number, may be rational, base 10 is default
NUM = [ ( +DIGIT "x" ) / ( "0" ( "b" / "o" / "h" / "d" )) ] *DIGIT [ "." +DIGIT ]

STRING = DQUOTE *(CHAR) DQUOTE

char = "'" CHAR "'"

ENDING = ";" / NEWLINE
NEWLINE = LF / CRLF